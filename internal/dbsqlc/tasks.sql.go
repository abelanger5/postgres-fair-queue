// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: tasks.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const popTasks = `-- name: PopTasks :many
WITH
    eligible_tasks AS (
        SELECT
            tasks.id
        FROM
            tasks
        WHERE
            "status" = 'QUEUED' 
        ORDER BY id ASC
        FOR UPDATE SKIP LOCKED
        LIMIT
            COALESCE($1::int, 10)
    )
UPDATE tasks
SET
    "status" = 'RUNNING'
FROM
    eligible_tasks
WHERE
    tasks.id = eligible_tasks.id
RETURNING tasks.id, tasks.created_at, tasks.status, tasks.args, tasks.group_key
`

func (q *Queries) PopTasks(ctx context.Context, db DBTX, limit pgtype.Int4) ([]*Task, error) {
	rows, err := db.Query(ctx, popTasks, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Status,
			&i.Args,
			&i.GroupKey,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const popTasksWithConcurrency = `-- name: PopTasksWithConcurrency :many
WITH
    min_id AS (
        SELECT
            COALESCE(min(id), 0) AS min_id
        FROM
            tasks
        WHERE
            "status" = 'QUEUED'
    ),
    eligible_tasks AS (
        SELECT
            tasks.id
        FROM
            tasks
        WHERE
            "status" = 'QUEUED' AND
            "id" >= (SELECT min_id FROM min_id) AND
            "id" < (SELECT min_id FROM min_id) + $1::int * 1024 * 1024
        ORDER BY id ASC
        FOR UPDATE SKIP LOCKED
        LIMIT
            COALESCE($2::int, 10)
    )
UPDATE tasks
SET
    "status" = 'RUNNING'
FROM
    eligible_tasks
WHERE
    tasks.id = eligible_tasks.id
RETURNING tasks.id, tasks.created_at, tasks.status, tasks.args, tasks.group_key
`

type PopTasksWithConcurrencyParams struct {
	Concurrency int32       `json:"concurrency"`
	Limit       pgtype.Int4 `json:"limit"`
}

func (q *Queries) PopTasksWithConcurrency(ctx context.Context, db DBTX, arg PopTasksWithConcurrencyParams) ([]*Task, error) {
	rows, err := db.Query(ctx, popTasksWithConcurrency, arg.Concurrency, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Status,
			&i.Args,
			&i.GroupKey,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTaskPtrs = `-- name: UpdateTaskPtrs :one
WITH 
    max_assigned_id AS (
        SELECT
            id
        FROM
            tasks
        WHERE
            "status" != 'QUEUED'
        ORDER BY id DESC
        LIMIT 1
    )
UPDATE task_addr_ptrs
SET
    max_assigned_block_addr = COALESCE(
        FLOOR((SELECT id FROM max_assigned_id)::decimal / 1024 / 1024), 
        COALESCE(
            (SELECT MAX(block_addr) FROM task_groups),
            0
        )
    )
FROM
    max_assigned_id
RETURNING task_addr_ptrs.max_assigned_block_addr, task_addr_ptrs.onerow_id
`

func (q *Queries) UpdateTaskPtrs(ctx context.Context, db DBTX) (*TaskAddrPtr, error) {
	row := db.QueryRow(ctx, updateTaskPtrs)
	var i TaskAddrPtr
	err := row.Scan(&i.MaxAssignedBlockAddr, &i.OnerowID)
	return &i, err
}

const updateTaskStatus = `-- name: UpdateTaskStatus :one
UPDATE tasks
SET
    "status" = COALESCE($1::"TaskStatus", "status")
WHERE
    id = $2::bigint
RETURNING id, created_at, status, args, group_key
`

type UpdateTaskStatusParams struct {
	Status NullTaskStatus `json:"status"`
	ID     pgtype.Int8    `json:"id"`
}

func (q *Queries) UpdateTaskStatus(ctx context.Context, db DBTX, arg UpdateTaskStatusParams) (*Task, error) {
	row := db.QueryRow(ctx, updateTaskStatus, arg.Status, arg.ID)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Status,
		&i.Args,
		&i.GroupKey,
	)
	return &i, err
}
